要想了解多线程，必须先了解线程;想要了解线程，必须先了解进程，因为线程是依赖进程而存在的。

进程：
   就是正在运行的程序，进程是系统进行资源分配和调度的独立单位。每一个进程都有它自己的内存空间和系统资源。

线程:
   在同一个进程内又可以执行多个任务，而这每一个任务我就可以看出是一个线程。
   线程:是程序的执行单元，执行路径。是程序使用cpu的最基本单位。
   单线程：如果程序只有一条执行路径
   多线程：如果程序有多条执行路径
   
多进程的意义:
   多进程的存在，不是提高了程序的执行速度，而是提高应用程序的使用率。
   程度的执行其实都是在抢cpu的资源，cpu的执行权。
   多个进程是在抢这个资源，而其中的某一个进程如果执行路径比较多，就会有更高的几率抢到cpu的执行权
   我们是不敢保证哪一个线程能够在哪个时刻抢到，所以线程的执行有随机性.
 
 并行与并发：
   前者是逻辑上同时发生，指在某一个时间内同时运行多个程序
   后者是物理上同时发生，指在某一个时间内同时运行多个程序
   
 Java程序的运行原理：
   由java命令启动JVM,JVM启动就相当于启动了一个进程。接着由该进程创建一个主线程去调用main方法。
 
 jvm虚拟机的启动是单线程的还是多线程的?
     多线程，起码有一个垃圾回收线程和主线程
 
 多线程的实现方案
   1.继承Thread类:
             需要重写run方法。为什么？因为类中的所有代码都需要被线程执行，而这个时候，为了区别哪些代码能够被线程执行
       java提供了Thread类中的run()用来包含那些被线程执行的代码。  
     
     run()和start()的区别:
         前者仅仅是封装 被线程执行的代码，直接调用是普通方法；后者启动了线程，然后由jvm去调用该线程的run()方法.
   
   2.实现Runnable接口:
         也是重写run方法。   
   
   3.两种实现方式的优缺点:
            采用继承Thread类方式：
                 （1）优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程。
                 （2）缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。
        采用实现Runnable接口方式：
                 （1）优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相 同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
                 （2）缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。
 
 线程的调度和优先级问题：
		A:线程的调度
			a:分时调度
			b:抢占式调度 (Java采用的是该调度方式)
		B:获取和设置线程优先级
			a:默认是5
			b:范围是1-10
  
 线程的控制(常见方法)
		A:休眠线程
		B:加入线程
		C:礼让线程
		D:后台线程
		E:终止线程(掌握)
		
线程的生命周期(参照	线程生命周期图解.bmp)
		A:新建
		B:就
		C:运行
		D:阻塞
		E:死亡
   
 ----------------------------------------------------
--请简述sleep()与wait()方法的区别
   sleep()是Thread类的，而wait()是Object类的。
   sleep()没有释放锁，而wait()释放了锁，使得其他线程可以使用同步控制块或方法
   wait只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用
   sleep必须捕获异常，而wait不需要捕获异常
 --------------------------------------------------------------------------
 synchronized 和 volatile 关键字的作用
	一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：
	 1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是
	立即可见的。
	 2）禁止进行指令重排序。
		volatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；
		synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
	  1.volatile 仅能使用在变量级别；
	    synchronized 则可以使用在变量、方法、和类级别的
	  2.volatile 仅能实现变量的修改可见性，并不能保证原子性；
	    synchronized 则可以保证变量的修改可见性和原子性
	  3.volatile 不会造成线程的阻塞；
	    synchronized 可能会造成线程的阻塞。
	  4.volatile 标记的变量不会被编译器优化；
	    synchronized 标记的变量可以被编译器优化
   
 
  
   